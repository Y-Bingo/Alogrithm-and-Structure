# 排序算法

@[TOC]

**说明：**
* 排序算法的实现均为正序(从小到大)
* 实现的语言为Typescript

## 0 算法概述

### 0.1 算法分类
**十种常见排序算法可以分为两大类：**
* 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
* 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。


### 0.2 相关概念
* 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
* 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
* 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
* 空间复杂度：是指算法在计算机

### 0.3 算法复杂度
 排序  |    时间复杂度（平局）    |    时间复杂度（最坏）    |    时间复杂度（最好）    |       空间复杂度       | 稳定性
:-----:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:-----:
 冒泡  |        O( n² )         |        O( n² )         |         O( n )         |         O( 1 )         |  稳定
 选择  |        O( n² )         |        O( n² )         |        O( n² )         |         O( 1 )         | 不稳定
 插入  |        O( n² )         |        O( n² )         |         O( n )         |         O( 1 )         |  稳定
 希尔  |  O( n<sup>1.3</sup> )  |        O( n² )         |         O( n )         |         O( 1 )         | 不稳定
 归并  | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) |  稳定
 快速  | O( nlog<sub>2</sub>n ) |        O( n² )         | O( nlog<sub>2</sub>n ) |         O( 1 )         | 不稳定
  堆   | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) |         O( 1 )         | 不稳定
&nbsp; |         &nbsp;         |         &nbsp;         |         &nbsp;         |         &nbsp;         | &nbsp;
 计数  |       O( n + k )       |       O( n + k )       |       O( n + k )       |       O( n + k )       |  稳定
  桶   |       O( n + k )       |        O( n² )         |         O( n )         |       O( n + k )       |  稳定
 基数  |       O( n * k )       |       O( n * k )       |      O( n * k  )       |       O( n + k )       |  稳定


## 1 冒泡排序 ( Bubble Sort )
> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端

### 1.1 算法描述
1. 比较相邻的元素，如果第一个比第二个大，则交换位置
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数
3. 针对所有的元素重复以上的步骤，除了最后一个（已经确定的元素）
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

### 1.2 代码实现
```TypeScript
    function BubbleSort ( arr: any[], len: number = arr.length ){
        let i = 0, j = 0;
        for ( ; i < len; i++ ) {
            for ( ; j < len - i - 1; j++ ) {
                if ( arr[ j ] > arr[ j + 1 ] ) continue;
                [ arr[ j ], arr[ j + 1 ] ] = [ arr[ j + 1 ], arr[ j ] ];
            }
        }
    }
```

### 1.3 算法分析
排序 | 时间复杂度（平局） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性
:-:|:----------------:|:----------------:|:----------------:|:----------:|:--:
冒泡 |     O( n² )      |     O( n² )      |      O( n )      |   O( 1 )   |  稳定

## 2 选择排序 ( Selection Sort )
> 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

### 2.1 算法描述
* 从待排序序列中，找到关键字最小的元素
* 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换
* 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束

### 2.2  代码实现
```TypeScript
    function SelectSort( arr: any[], len: number = arr.length):void {
        let minIndex = -1;
        let i = 0, j = 0;
        for( ; i < len - 1; i++ ) {
            minIndex = i;
            for( j = i ; j < len ; j++ ) {
                if( arr[ minIndex] > arr[ j ] )
                    minIndex = j;
            }
            [ arr[ i ], arr[ minIndex ] ] = [ arr[ minIndex],arr[ i ] ];
        }
    }
```

### 2.3 算法分析
排序 | 时间复杂度（平局） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性
:-:|:----------------:|:----------------:|:----------------:|:----------:|:--:
选择 |     O( n² )      |     O( n² )      |     O( n² )      |   O( 1 )   | 不稳定

* 选择排序算法中的比较次数与元素的初始排列无关，因为总是必须比较后面的待排序元素已确定当前元素具有最小的排序码
* 素的移动次数与元素的初始排列有关，因为当元素是从小到大排序时，移动次数是0；而最坏情况下，每次都要进行交换，移动次数是 3*（n-1）
* 表现最稳定（指时间复杂度）的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好
* 唯一的好处可能就是不占用额外的内存空间了吧

## 3 插入排序 ( Insertion Sort )
> 过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入

### 3.1 算法描述
1. 从第一个元素开始，该元素可以被认为已经被排好序
2. 取出下一个元素(N)，在已经排序的元素(M)序列中从后面向前扫描
3. 如果元素(M)大于元素(N)，该元素( N )移到下一位置
4. 重复步骤3，知道找到已排序元素(M)小于或者等于元素(N)的位置
5. 将元素(N)插入到该位置后
6. 重复步骤2~5

### 3.2 代码实现
```TypeScript
    // 直接版
    function InsertSort( arr: any[], len: number= arr.length ): void {
        let i = 0 , j = 0;
        for( ; i < len; i++ ) {
            for( j = i - 1; j >= 0 ; j-- ) {
                if( arr[ j + 1 ] >= arr[ j ] ) break;
                [ arr[ j + 1 ], arr[ j ] ] = [ arr[ j ], arr[ j + 1] ];
            }
        }
    }
```
```TypeScript
    // 优化版： 较少交换的次数
    function InsertSort( arr: any[], len: number= arr.length ): void {
        let i = 0 , j = 0;
        let N = null;
        for( ; i < len; i++ ) {
            N = arr[ i ];
            for( j = i ; j >= 0 ; j-- ) {
                if( N >= arr[ j - 1 ] ) break;
                arr[ j ] = arr[ j - 1 ];
            }
            arr[ j ] = N;
        }
    }
```

### 3.3 算法分析
排序 | 时间复杂度（平局） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性
:-:|:----------------:|:----------------:|:----------------:|:----------:|:--:
插入 |     O( n² )      |     O( n² )      |      O( n )      |   O( 1 )   |  稳定

* 具有能够提早结束向前搜索（第二层循环）的特点
* 对于有序数组，插入的排序的时间复杂度为O(n)
* 对于规模较小或者部分有序，甚至有序的数据来说，使用插入排序的效率比部分O(nlogn)的排序算法效率更高！

## 4 希尔排序 ( Shell Sort )
> 第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

### 4.1 算法描述
先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序

1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1 ( 一般 t1 = len / 2 )
2. 按增量序列个数k，对序列进行k 趟排序
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度

**换个角度理解：**希尔排序就是一个升级版的插入排序或者是插入排序的优化，为了迎合插入排序的优点，把一个大的数据拆分成多个**规模较小**的数据，并对其进行插入排序。增量为1时，数据规模为n，此时数据已经是一个**相对有序（部分）**，再进行一次插入排序

### 4.2 代码实现
```TypeScript
    function ShellSort( arr: any[], len: number = arr.length ) {
        let d = len >> 1;   // 增量 一般为选区数据长度一半
        let i = 0, j = 0 ;
        let N = null;
        while( d > 0 ) {
            // 对各个分组进行插入排序
            for( i = d; i < len ; i++ ) {
                N = arr[ i ];
                for( j = i - d; j < len ; j -= d ) {
                    if( N > arr[ j ] ) break;
                    arr[ j + d ] = arr[ j ];
                }
                arr[ j + gap ] = N;
            }
            d = d >> 1;
        }
    }
```

### 4.4 算法分析
希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。

排序 |   时间复杂度（平局）   | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性
:-:|:--------------------:|:----------------:|:----------------:|:----------:|:--:
插入 |       O( n² )        |     O( n² )      |      O( n )      |   O( 1 )   |  稳定
希尔 | O( n<sup>1.3</sup> ) |     O( n² )      |      O( n )      |   O( 1 )   | 不稳定


## 5 归并排序
> 该算法是采用**分治法（Divide and Conquer）**的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并

### 5.1 算法描述

1. 把长度为n的输入序列分成两个长度为n/2的子序列
2. 对这两个子序列分别采用归并排序
3. 将两个排序好的子序列合并成一个最终的排序序列

### 5.2 代码实现
```TypeScript
    // 归并范围为 [ l ,r ] 闭区间
    function MergeSort( arr: any[], l: number = 0 , r: number = arr.length - 1 ): void {

        if( l >= r ) return;
        // 找出中间位置
        let mid = ( l << 1 ) + ( r << 1 );
        // 归并左半部分
        MergeSort( arr, l , mid );
        // 归并右半部分
        MergeSrot( arr, mid + 1, r );
        // 合并左右
        merge( arr, 0, mid, len - 1 );
    }

    function merge( arr: any[], l: number, mid:number, r: number ): void {
        let aux = [];
        for ( let i = l, j = mid + 1, k = 0; k < r - l + 1; k++ ) {

            if ( i > mid ) {
                aux[ k ] = arr[ j ];
                j++;
            }
            else if ( j > r ) {
                aux[ k ] = arr[ i ];
                i++;
            } else if ( arr[ i ] < arr[ j ] ) {
                aux[ k ] = arr[ i ];
                i++;
            }
            else {
                aux[ k ] = arr[ j ];
                j++;
            }

        }
        // 把辅助数组的值赋值到原数组中
        for ( let q = l; q <= r; q++ )
            arr[ q ] = aux[ q - l ];
        }

    }
```

### 5.3 算法分析
归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

排序 |    时间复杂度（平局）    |    时间复杂度（最坏）    |    时间复杂度（最好）    |       空间复杂度       | 稳定性
:-:|:----------------------:|:----------------------:|:----------------------:|:----------------------:|:--:
归并 | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) |  稳定


## 6 快速排序( Quick Sort )
> 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序

### 6.1 算法描述
快速排序使用**分治法**来把一个串（list）分为两个子串（sub-lists）

1. 从数列中挑出一个元素，称为“基准”(pivot)
2. 重新排列数列，所有元素比基准小的摆放在基准前面，所有元素比基准值大的摆放在基准后面（相同的数可以摆放到任何一边）。在这个分区退出后，该基准就处于数列的中间位置。这个叫做分区(partition)操作
3. 递归把小于基准元素的子数列和大于基准值元素的子数列排序

### 6.2 代码实现
```TypeScript
    function QuickSort ( arr: any[], l: number = 0, r: number = arr.length - 1 ): void {
        if ( l >= r ) return;

        let p = partition( arr, l, r );
        QuickSort( arr, l, p - 1 );
        QuickSort( arr, p + 1, r );

    }
    // 分区操作
    function partition ( arr: any[], l: number, r: number ): number {
        // 选取区间内的第一个元素作为基准
        let pivot = arr[ l ];
        let j = l + 1, i = j;

        for ( ; i <= r; i++ ) {
            // 大于基准值的，分配到右边
            if ( arr[ i ] > pivot ) continue;
            // 小于基准值，则把元素分配到左边
            [ arr[ i ], arr[ j ] ] = [ arr[ j ], arr[ i ] ];
            j++;
        }
        // 把已经分配好的元素的左半部最后一个元素与基准值交换
        [ arr[ l ], arr[ j - 1 ] ] = [ arr[ j - 1 ], arr[ l ] ];

        return j - 1;
    }
```

### 6.3 算法分析
排序 |    时间复杂度（平局）    | 时间复杂度（最坏） |    时间复杂度（最好）    | 空间复杂度 | 稳定性
:-:|:----------------------:|:----------------:|:----------------------:|:----------:|:--:
快速 | O( nlog<sub>2</sub>n ) |     O( n² )      | O( nlog<sub>2</sub>n ) |   O( 1 )   | 不稳定


* 如果对一个有序的数据进行排序，快排会退化成O(n^2),那是因为选区的基准不能很好的划分数据
* 面对有大量重复数据的一组数据，快排也因不能很好的划分区域，导致分区失衡退化

### 6.4 优化
1. 随机基准，选基准不再是从第一个元素开始，而是在分区操作的区域中随机选取一个，防止分区不均匀
2. 多路快排，把数据相同的元素平均分派到各路

```TypeScript
    function partition2( arr: any[], l: number , r: number ) {
        // 随机抽取基准
        let randomIndex = Math.floor( Math.random() * ( r - l ) ) + l;
        [ arr[ randomIndex ], arr[ l ] ] = [ arr[ l ], arr[ randomIndex ] ];
        let paviot = arr[ l ];
        // 双路
        let i = l , j = r;
        while( 1 ) {
            while( i <= r && arr[ i ] <= paviot ) i++;
            while( j >= l && arr[ j ] >= paviot ) j--;
            if( i >= j ) break;
            [ arr[ i ], arr[ j ] ] = [ arr[ j ], arr[ i ] ];
            i++;
            j++;
        }
        [ arr[ l ], arr[ j ]  ] = [ arr[ j ], arr[ l ] ];
        return j;
    }
```

## 7 堆排序( Heap Sort )
> 是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点

### 7.1 算法描述

1. 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区
2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]
3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成

### 7.2 代码实现
```TypeScript
    function HeapSort ( arr: any[], end: number = arr.length - 1 ) {
        // 把数组变成一个堆
        for ( let i = ( end - 1 ) >> 1; i >= 0; i-- )
            _shiftDown2( arr, i, end );

        for ( let i = end; i >= 0; i-- ) {
            [ arr[ i ], arr[ 0 ] ] = [ arr[ 0 ], arr[ i ] ];
            _shiftDown2( arr, 0, i - 1 );
        }
    }
```

```TypeScript
    // shift down 过程
    function _shiftDown ( arr: any[], parent: number, end: number ) {
        /**
         * 左孩子 index * 2 + 1
         * 右孩子 index * 2 + 2
         */
        let child = parent * 2 + 1;
        while ( child <= end ) {

            if ( child + 1 <= end && arr[ child + 1 ] > arr[ child ] )
                child += 1;

            if ( arr[ parent ] >= arr[ child ] ) break;

            [ arr[ child ], arr[ parent ] ] = [ arr[ parent ], arr[ child ] ];

            parent = child;
            child = parent * 2 + 1;
        }
    }
```

```TypeScript
    // shift down 美化
    function _shiftDown2 ( arr: any[], T: number, end: number ) {
        /**
         * 左孩子 index * 2 + 1
         * 右孩子 index * 2 + 2
         */
        let t = T;
        while ( T * 2 + 1 <= end ) {

            t = T * 2 + 1;

            if ( t + 1 <= end && arr[ t + 1 ] > arr[ t ] )
                t += 1;

            if ( arr[ T ] >= arr[ t ] ) break;

            [ arr[ T ], arr[ t ] ] = [ arr[ t ], arr[ T ] ];

            T = t;
        }
    }
```

### 7.3 算法分析
排序 |    时间复杂度（平局）    |    时间复杂度（最坏）    |    时间复杂度（最好）    | 空间复杂度 | 稳定性
:--:|:----------------------:|:----------------------:|:----------------------:|:----------:|:--:
 堆  | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) | O( nlog<sub>2</sub>n ) |   O( 1 )   | 不稳定

## 参考
* [十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/articles/7674659.html)
* [稳定排序与不稳定排序](https://blog.csdn.net/lzq20115395/article/details/81078099)
